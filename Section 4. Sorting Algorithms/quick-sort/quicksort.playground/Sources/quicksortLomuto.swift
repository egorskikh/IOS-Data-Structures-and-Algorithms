import Foundation

public func partitionLomuto<T: Comparable>(_ a: inout [T],
                                           low: Int,
                                           high: Int) -> Int {
    /*
     Установите шарнир. Ломуто всегда выбирает последний элемент в качестве стержня.
     */
    let pivot = a[high]
    
    /*
     Переменная i указывает, сколько элементов меньше, чем точка поворота.
     Каждый раз, когда вы сталкиваетесь с элементом, который меньше точки поворота,
     вы меняете его местами с элементом с индексом i и увеличиваете i.
     */
    var i = low
    
    /*
     Прокрутите все элементы от низкого до высокого, но не включая высокий, так как это стержень.
     */
    for j in low..<high {
        
        /*
         Убедитесь, что текущий элемент меньше или равен оси поворота.
         */
        if a[j] <= pivot {
            
            /*
             Если это так, замените его элементом с индексом i и увеличьте i.
             */
            a.swapAt(i, j)
            i += 1
        }
    }
    
    /*
     Закончив с петлей, поменяйте местами элемент в точке i с точкой поворота.
     Ось всегда находится между меньшим и большим разделами.
     */
    a.swapAt(i, high)
    
    /*
     Верните индекс оси поворота.
     */
    return i
}

/*
 Здесь вы просто применяете алгоритм Ломуто для разделения массива на две области,
 а затем рекурсивно сортируете эти области.
 Рекурсия заканчивается, когда в регионе меньше двух элементов.
 */
public func quicksortLomuto<T: Comparable>(_ a: inout [T],
                                           low: Int,
                                           high: Int) {
    if low < high {
        let pivot = partitionLomuto(&a, low: low, high: high)
        quicksortLomuto(&a, low: low, high: pivot - 1)
        quicksortLomuto(&a, low: pivot + 1, high: high)
    }
    
}
